import struct

#bytes in python suck
Bips = {struct.pack("!B", n) : n for n in range(256)} # Поскольку питон у нас дохера умный, он любит переводить байты в char, поэтому, если попросить его вывести 32, переведённое в байтах - он выведет тебе ебучий пробел
revBips = {n : struct.pack("!B", n) for n in range(256)} #Мог-бы быть и простым массивом, но для красоты пусть будет так, разницы всё-равно никакой
#Эти два прекрасных массива сидят здесь для перевода кривого отображения питоновского байта в околочеловеческие, десятичные значения и обратно

adress = float(input("Введите адрес: "))

newSet1 = float(input("Введите новые показания счётчиков: "))
newSet1 = float(input("Введите новые показания счётчиков: "))
newSet1 = float(input("Введите новые показания счётчиков: "))


#Данные, необходимые для записи
C_read = [3] # Код для чтения регистра
C_wrrite = [16] # Код для записи регистра

C_Key_adr = [0, 0, 0, 1] # Адрес ключа для записи показаний счётчиков
C_Key_len = [8] # Длина ключа для записи счётчиков (также это длина кода для записи показаний)

С_oldSet_adr_1 = [21, 126, 0, 2] # Адрес регистра (включая длину), в котором находятся старые показания счётчика №1 = 15 7E 00 02
С_oldSet_adr_2 = [21, 128, 0, 2] # Адрес регистра (включая длину), в котором находятся старые показания счётчика №2 = 15 8E 00 02
С_oldSet_adr_3 = [21, 130, 0, 2] # Адрес регистра (включая длину), в котором находятся старые показания счётчика №3 = 15 82 00 02

C_Write_open = [21, 73, 0, 1, 2, 83, 0] # Адрес, и значения, которые нужно установить перед началом сеанса записи = 15 49 00 01 02 53 00
C_Short_init = [22, 140, 0, 4] # Форма малой инициализации (та самая, что требует ключ и вводится перед каждой записью) = 16 8C 00 04
C_Write_close = [21, 73, 0, 1, 2, 0, 0] # 15 49 00 01 02 00 00  Закрытие сеанса записи

С_newSet_adr_1 = [22, 122, 0, 4] # Адрес, по которому будут записаны новые показания (разность) = 16 7A 00 04
С_newSet_adr_2 = [22, 124, 0, 4] # Адрес, по которому будут записаны новые показания (разность) = 16 7C 00 04
С_newSet_adr_3 = [22, 126, 0, 4] # Адрес, по которому будут записаны новые показания (разность) = 16 7E 00 04
Trm = [28, 247, 25, 0] # Терминатор, последовательность, обозначающая конец записи (используется только для записи показаний счётчиков) = 1C F7 19 00



def CRC16(data): # Функция, вычисляющая контрольную сумму по методу CRC16, контрольная сумма идёт в конце каждого пакета
    poly = 0xa001 # На вход подаётся массив байт прямого порядка
    xor1 = 0x0000
    crc = 0xffff
    len_ = len(data)
    i = 0

    while len_: 
        len_ -= 1
        crc ^= (data[i])
        i += 1        
        
        for j in range(0, 8):    
            if crc & 0x0001:
                crc = (crc >> 1) ^ poly
            else:
                crc = crc >> 1
            
    crc ^= xor1
    return crc # На выход получаем число, перевод которого в шестнадцатеричное представление даст нам контрольную сумм в прямом порядке !!!ПЕРЕД ОТПРАВКОЙ ОБЯЗАТЕЛЬНО РАЗДЕЛИТЬ ПО БАЙТАМ И РАЗВЕРНУТЬ В ОБРАТНЫЙ ПОРЯДОК!!!

def CRC16_to_send(int_data): # Получая на вход контрольную сумму, возвращаемую функцией CRC16(), в виде числа int, переводит его в стандартную форму (массив байт), и разворачивает в обратную последовательность
    ret = []
    ret.append(int_data % 256)
    ret.append(int_data // 256)
    return ret # Результат работы этой функции можно отправлять вместе с остальными данными

