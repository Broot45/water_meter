import struct

#bytes in python suck
Bips = {struct.pack("!B", n) : n for n in range(256)} # Поскольку питон у нас дохера умный, он любит переводить байты в char, поэтому, если попросить его вывести 32, переведённое в байтах - он выведет тебе ебучий пробел
revBips = {n : struct.pack("!B", n) for n in range(256)} #Мог-бы быть и простым массивом, но для красоты пусть будет так, разницы всё-равно никакой
#Эти два прекрасных массива сидят здесь для перевода кривого отображения питоновского байта в околочеловеческие, десятичные значения и обратно

adress = 45 #int(input("Введите адрес: "))

newSet1 = 120.0 #float(input("Введите новые показания счётчиков: "))
newSet1 = 40.0 #float(input("Введите новые показания счётчиков: "))
newSet1 = 3.0 #float(input("Введите новые показания счётчиков: "))


#Данные, необходимые для записи
C_Read = [3] # Код для чтения регистра
C_Write = [16] # Код для записи регистра

C_Key_adr = [0, 0, 0, 1] # Адрес ключа для записи показаний счётчиков (включая длину)
C_Key_len = [8] # Длина ключа для записи счётчиков (также это длина кода для записи показаний)

С_oldSet_adr_1 = [21, 126, 0, 2] # Адрес регистра (включая длину), в котором находятся старые показания счётчика №1 = 15 7E 00 02
С_oldSet_adr_2 = [21, 128, 0, 2] # Адрес регистра (включая длину), в котором находятся старые показания счётчика №2 = 15 8E 00 02
С_oldSet_adr_3 = [21, 130, 0, 2] # Адрес регистра (включая длину), в котором находятся старые показания счётчика №3 = 15 82 00 02

C_Write_open = [21, 73, 0, 1, 2, 83, 0] # Адрес, и значения, которые нужно установить перед началом сеанса записи = 15 49 00 01 02 53 00
C_Short_init = [22, 140, 0, 4] # Форма малой инициализации (та самая, что требует ключ и вводится перед каждой записью) = 16 8C 00 04
C_Write_close = [21, 73, 0, 1, 2, 0, 0] # 15 49 00 01 02 00 00  Закрытие сеанса записи

С_newSet_adr_1 = [22, 122, 0, 4] # Адрес, по которому будут записаны новые показания (разность) = 16 7A 00 04
С_newSet_adr_2 = [22, 124, 0, 4] # Адрес, по которому будут записаны новые показания (разность) = 16 7C 00 04
С_newSet_adr_3 = [22, 126, 0, 4] # Адрес, по которому будут записаны новые показания (разность) = 16 7E 00 04
Trm = [28, 247, 25, 0] # Терминатор, последовательность, обозначающая конец записи (используется только для записи показаний счётчиков) = 1C F7 19 00


#=================================Тест на нескольких машинах=============================
def CRC16(data: list): # Функция, вычисляющая контрольную сумму по методу CRC16, контрольная сумма идёт в конце каждого пакета
    poly = 0xa001 # На вход подаётся массив байт прямого порядка
    xor1 = 0x0000
    crc = 0xffff
    len_ = len(data)
    i = 0

    while len_: 
        len_ -= 1
        crc ^= (data[i])
        i += 1        
        
        for j in range(0, 8):    
            if crc & 0x0001:
                crc = (crc >> 1) ^ poly
            else:
                crc = crc >> 1
            
    crc ^= xor1
    return crc # На выход получаем число, перевод которого в шестнадцатеричное представление даст нам контрольную сумм в прямом порядке !!!ПЕРЕД ОТПРАВКОЙ ОБЯЗАТЕЛЬНО РАЗДЕЛИТЬ ПО БАЙТАМ И РАЗВЕРНУТЬ В ОБРАТНЫЙ ПОРЯДОК!!!

def CRC16_to_send(int_data: int): # Получая на вход контрольную сумму, возвращаемую функцией CRC16(), в виде числа int, переводит его в стандартную форму (массив байт), и разворачивает в обратную последовательность
    ret = []
    ret.append(int_data % 256)
    ret.append(int_data // 256)
    return ret # Результат работы этой функции можно отправлять вместе с остальными данными
#======================================Тест на нескольких машинах================================
def get_Read(data: list): # Сбор полезной нагрузки из ответа, отправленного устройством
    stop = len(data) - 2
    return data[3:stop]

def Transmit(msg: list): # Составление контрольной суммы и отправка пакета данных
    temp = [] # Временный массив
    temp = CRC16(msg) # Вычисление контрольной суммы
    temp = CRC16_to_send(temp)
    msg.extend(temp)
    print(send) # !!! Вместо печати поставитить отправку через порт !!!
    ################################################### в эту строку поставить приём ответа, и выслать его через return, после пересмотреть все вызовы этой функции, и заменить способ вызова
    send.clear()

# Подготовка данных к записи

send = [] # Лист для отправки байт
# Сборка запроса на получение ключа
send.append(adress)
send.extend(C_Read)
send.extend(C_Key_adr)
Transmit(send)
send.clear()

Key = [45, 3, 8, 50, 51, 48, 56, 48, 50, 52, 53, 92, 164] # !!! В будущем эта строка должна принимать значение с порта !!! (адрес, команда, длина, сама инфа, CRC16, CRC16)
Key = get_Read(Key)

# Сбор старых показаний
send.append(adress)
send.extend(C_Read)
send.extend(С_oldSet_adr_1)
Transmit(send)
send.clear()

oldSet1 = [45, 3, 4, 10, 215, 115, 64, 128, 209] # 2D 03 04 0A D7 73 40 80 D1 = 3.81
oldSet1 = get_Read(oldSet1) # Собираем полезные данные (Старые показания счётчика №1)
oldSet1.reverse() # Поскольку они представлены в обратном порядке, возвращаем его к стандартному (в пределах этой программы)


send.append(adress)
send.extend(C_Read)
send.extend(С_oldSet_adr_2)
Transmit(send)
send.clear()

oldSet2 = [45, 3, 4, 204, 161, 149, 63, 86, 3] # 2D 03 04 CC A1 95 3F 56 03 = 1.169
oldSet2 = get_Read(oldSet2)
oldSet2.reverse()

send.append(adress)
send.extend(C_Read)
send.extend(С_oldSet_adr_3)
Transmit(send)
send.clear()

oldSet3 = [45, 3, 4, 65, 96, 101, 60, 40, 146] # 2D | 03 | 04 | 41 60 65 3C | 28 92 = 0.014
oldSet3 = get_Read(oldSet3)
oldSet3.reverse()

print(oldSet2)
