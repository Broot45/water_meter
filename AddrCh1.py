import struct # Для работы с байтами
import serial # Для работы с портами
import time # КД запросов

PORT = '/dev/ttyUSB0' # Порт общения с платой

fullAddr = int(input("Полный адрес: ")) # Полный адрес счётчика, 8 цифр
shortAddr = int(input("Краткое обращение: ")) # Краткий адрес, по которому общаются остальные программы, 0-247

ser = serial.Serial(PORT, baudrate=2400, timeout = 0.5) # Открытие порта с частотой и таймаутом


# Скопированный блок, в данном случае в качестве параметра lenght передаётся int длины, поскольку автовычисление не сработает
def read_from_port(lenght): # Ахтунг, в функции не предусмотрена защита от некорректных данных
            global ser
            # Все условия подразумевают исправную работу счётчиков, сети, и самой программы в целом...
            # ...Если потребуется это исправить - можно засунуть всю функцию в try, и при любой ошибке, вместо чтения, просто... 
            # ...открывать и закрывать порт, понадеявшись, что в данный момент ответ был нам не сильно нужен

            if (not (type(lenght) is int) and (lenght != None)): return [None] # Отсев некорректных значений

            mas = [] # Массив первичных значений, содержит элементы типа byte, обращаться с сторожностью, поскольку питон любит их переводить в хуйню без спросу
            
            if lenght == None: # Если значение не установлено (по умолчанию None), функция сама из содержания вычислит, сколько нужно прочесть
                for n in "12345": mas.append(ser.read()) # Читаем первые пять байт, которые гарантированно будут присутствовать в корректном ответе
                if struct.unpack('<B', mas[1])[0] == 16: lenght = 3 # Если ответ на команду записи, то мы читаем 5 + 3 байта, сообщение об успешной записи
                elif struct.unpack('<B', mas[1])[0] == 3: lenght = struct.unpack('<B', mas[2])[0] # Если ответ на команду чтения, то мы читаем 5 байт системной информации (адрес, команда, $Количество и два байта CRC16), + $Количество
                else: # Если ответ не стандартен
                    lenght = 0
                    ser.close()
                    ser = serial.Serial(PORT, 2400, timeout = 0.5)


            while lenght > 0: # Дочитываем $Оставшееся количество байт (если число было фиксированным, то $Оставшееся = $Необходимое)
                mas.append(ser.read())
                lenght -= 1
            
            ans = [] # Массив вторичных, готовых к отправке значений
            for n in mas:
                try:
                    ans.append(struct.unpack('<B', n)[0]) # Перевод первичного значения во вторичное
                except:
                    ans.append(255)
            return ans